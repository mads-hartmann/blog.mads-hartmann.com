---
layout: post
title: "Exporting org from Make"
date:   2016-07-03 07:00:00
---
<p>
Recently I've been quite obsessed with <a href="https://www.gnu.org/software/make/">Make</a>. I think it might be the
perfect tool to deal with complex software projects that consist of
many different systems that are build using various languages (my
team at <a href="https://issuu.com/about">issuu</a> uses it to the build, test, &amp; deploy our frontend,
backend and various internal tools). However, I'll save that rant for
another blog post but given my fascination with Make I recently set out
to write a <code>Makefile</code> for this blog.
</p>

<p>
This blog is currently written in an awkward mix of <a href="http://orgmode.org/">org-mode</a> and
<a href="https://jekyllrb.com/">jekyll</a>. Previously my work-flow has been to manually start <code>jekyll
serve -w</code> and then export <code>org-mode</code> files from within <code>emacs</code>. This is
a bit tedious and it diverges from the work-flow I've come to expect
from my other projects where saving a file automatically triggers a
rebuild.
</p>

<p>
In this blog post I'll explain how I was able to export my <code>org-mode</code>
files from a <code>Makefile</code>. You can find the entire solution on Github at
<a href="http://github.com/mads-hartmann/mads-hartmann.github.com">mads-hartmann/mads-hartmann.github.com</a>.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Publishing from the shell</h2>
<div class="outline-text-2" id="text-1">
<p>
The first step was to figure out how to publish a single <code>org-mode</code>
file from the shell. Turns out that this could be achieved fairly
easily by using some of the command-line arguments that emacs provide.
</p>

<div class="org-src-container">

<pre class="src src-sh">  emacs \
      --quick \
      --directory &lt;path-to-org-mode&gt; \
      --script init.el \
      --eval "(org-publish-file \"&lt;path-to-org-file&gt;\" nil nil)"
</pre>
</div>

<p>
Lets look at each of the options:
</p>

<ul class="org-ul">
<li><b><code>--quick</code></b> is used to reduce the boot time of emacs. It's
equivalent to using all of <code>--no-init-file</code>, <code>--no-site-file</code>,
<code>--no-site-lisp</code> and <code>--no-splash</code>, that is, it will start a
bare-bones version of emacs that doesn't use any of your personal
configuration or packages.
</li>

<li><b><code>--directory</code></b> adds a directory to the emacs load path. In this
case I use it to add <code>org-mode</code> to the load path.
</li>

<li><b><code>--script</code></b> tells <code>emacs</code> to run a file as an Emacs Lisp script. In
this case I use it to run a script, <code>init.el</code>, that configures
<code>org-mode</code> so it knows how to publish my project. Using <code>--script</code>
also has the convenient effect that <code>emacs</code> doesn't start an
interactive display; it simply executes the script and
exits. Together with <code>--eval</code> this means you can use <code>emacs</code> just as
an interpreter for Emacs Lisp which is exactly what we need in this
case.
</li>

<li><b><code>--eval</code></b> tells emacs to evaluate an Emacs Lisp expression. The
expression that I'm using publishes an <code>org-mode</code> file.
</li>
</ul>

<p>
This is all there is to it. Writing a <code>Makefile</code> that runs this command
for each <code>.org</code> file and watches for changes to perform a rebuild is
fairly simple (if you know Make, if not I strongly recommend the first
couple of chapters <a href="http://www.oreilly.com/openbook/make3/book/index.csp">Managing Projects with GNU Make</a>, it's awesome.).
</p>

<div style="padding: 20px 40px;">
<p>
<b>Random thought</b> It's quite fun to play around with using <code>emacs</code> just for
its ability to interpret Emacs Lisp. You can play around with it like
this
</p>
<div class="org-src-container">

<pre class="src src-sh">  emacs --batch --eval "(message \"hi there\")"
</pre>
</div>
</div>

<p>
You could stop here and you would have a nice way to export <code>.org</code>
files from Make. However, I got curious and explored another way to do
it. In the next section I'll show a way to speed up the build-time a
bit &#x2013; it's really not necessary but it is quite fun and it requires a
couple of tricks that might be useful in other scenarios.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Speeding up the build using <code>emacsclient</code> and <code>emacs --daemon</code></h2>
<div class="outline-text-2" id="text-2">
<p>
<code>emacs</code> has the capability of starting an <code>emacs</code> server that you can
connect to using <code>emacsclient</code>. There are various use-cases for this
but in this case we'll use it to avoid having to start a fresh
<code>emacs</code> instance whenever we want to export an <code>org-mode</code> file.
</p>

<p>
Keeping the original goal in mind, that <code>make watch</code> should rebuild the
necessary things whenever a file is saved, here's what we want to have
running during <code>make watch</code>:
</p>

<ul class="org-ul">
<li><code>Jekyll</code> running in server mode so I can see my blog locally and
have it rebuild whenever a <code>.html</code> file changes.
</li>

<li>A loop that calls <code>make build</code> every second. This
is the simplest solution to re-export my <code>.org</code> files when they are
changed.
</li>
</ul>

<p>
Instead of having <code>make build</code> starting a fresh <code>emacs</code> every time a
file needs to be build (as we did in the previous section) let us
instead start an <code>emacs</code> server and connect to it using
<code>emacsclient</code>. This means our <code>make watch</code> target should have an extra
process running:
</p>

<ul class="org-ul">
<li>An <code>emacs</code> server that can export <code>.org</code> files.
</li>
</ul>

<p>
In order to achieved this we need to use a couple of tricks. I'll go
through each of them now.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> A target that runs other targets in parallel</h3>
<div class="outline-text-3" id="text-2-1">
<p>
In order to run these three <code>make</code> targets we'll introduce the first
trick. Using <code>xargs -P</code> to start processes. Here's a <code>Makefile</code> function
(or well, it's a <a href="https://www.gnu.org/software/make/manual/html_node/Multi_002dLine.html">multi-line variable</a> that supposed to be used with
<a href="https://www.gnu.org/software/make/manual/html_node/Call-Function.html#Call-Function">call</a>, but I like to think of it as a function) that will run all the <code>make</code>
targets you give it in separate processes
</p>

<div class="org-src-container">

<pre class="src src-makefile">  # $(call make-parallel, targets)
  #   Runs (sub) make targets, with each target running in a separate process
  define make-parallel
          $(call print-rule,$0,$1 - [$(words $1) targets])
          $(QUIET)echo $1 | xargs \
                  -n 1 \
                  -P $(words $1) \
                  $(MAKE) --no-print-directory -f $(firstword $(MAKEFILE_LIST))
  endef
</pre>
</div>

<p>
I then use it like this to run three targets in parallel
</p>
<div class="org-src-container">

<pre class="src src-makefile">  watch_targets := \
          _watch-continous-make \
          _watch-jekyll-server \
          _watch-emacs-server

  watch:
          $(call make-parallel, $(watch_targets))
</pre>
</div>

<p>
With this <code>make watch</code> will result in three invocations of <code>make</code>
running in parallel, namely <code>make _watch-emacs-server</code>, <code>make
_watch-jekyll-server</code> and <code>make _watch-emacs-server</code>. When I hit <code>^C</code>
(control-c) all of the processes are killed (as long as the targets
are running in the foreground).
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Starting and stopping an <code>emacs</code> daemon</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Now to the next piece of the puzzle, namely how to start, communicate
with, and stop and <code>emacs</code> daemon.
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> Starting &amp; stopping the server</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
By using the emacs command-line option <code>--daemon=&lt;daemon-name&gt;</code> you
can start an emacs server and give it a specific name. We explicitly
give the daemon a name so we can refer to it later. Here's how the
emacs daemon is started.
</p>

<div class="org-src-container">

<pre class="src src-sh">  emacs \
    --quick \
    --directory &lt;path-to-org-mode&gt; \
    --script init.el \
    --daemon=&lt;daemon-name&gt;
</pre>
</div>

<p>
Besides configuring <code>org-mode</code> I've added an extra important thing to the
<code>init.el</code> file that is required in order to start many daemons and have
<code>emacsclient</code> communicate with a specific one:
</p>

<div class="org-src-container">

<pre class="src src-elisp">  (setq server-use-tcp t) ;; If non-nil, use TCP sockets instead of local sockets.
</pre>
</div>

<p>
Alright, so that's how to get the <code>emacs</code> server up and running but
there's one problem. When using the <code>--daemon</code> option <code>emacs</code> will run
in the background. That's a problem as my <code>make-parallel</code> function
requires that all the targets run in the foreground in order to be
able to shut them down once I hit <code>^C</code>. In order to fix this I came up
with this little hack.
</p>

<div class="org-src-container">

<pre class="src src-sh">  #! /bin/sh

  trap "emacsclient --server-file=$1 --eval '(kill-emacs)'; exit" SIGINT SIGHUP SIGKILL
  tail -f /dev/null
</pre>
</div>

<p>
It's a shell script that will run forever (this is achieved by <code>tail
-f /dev/null</code>. However it also registers a <code>trap</code> for <code>SIGINT</code>,
<code>SIGHUP</code> and <code>SIGKILL</code> events. The <code>trap</code> kills the server by using
<code>emacsclient</code> to send <code>(kill-emacs)</code> to the server.
</p>

<p>
So the final <code>_watch-emacs-server</code> target looks like this
</p>

<div class="org-src-container">

<pre class="src src-makefile">  # Starts emacs in server-mode, blocks until SIGINT/SIGHUP/SIGKILL is
  # sent and then shuts down the emacs server instance.
  _watch-emacs-server:
          $(QUIET)emacs \
                  --quick \
                  --directory $(abspath $(setup.dir)/org-$(org_version)/lisp) \
                  --script init.el \
                  --daemon=$(strip $(emacs_daemon_name)) $(if $(QUIET),&amp;&gt; /dev/null,)
          $(QUIET)sh wait-and-shutdown.sh $(emacs_daemon_name)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> Communicating with the server</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
Once the daemon is running you can start an <code>emacsclient</code> and use it to export
an <code>.org</code> file like this.
</p>

<div class="org-src-container">

<pre class="src src-sh">  emacsclient \
    --server-file=$(strip $(emacs_daemon_name)) \
    --eval "(org-publish-file \"&lt;path-to-org-file&gt;\" nil nil)"
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Continuous <code>make build</code></h3>
<div class="outline-text-3" id="text-2-3">
<p>
The last trick is to create a make target that simply calls <code>make build</code>
every second.
</p>
<div class="org-src-container">

<pre class="src src-makefile">  # Calls `make build` every second.
  _watch-continous-make:
          $(QUIET)while true; do \
                  sleep 1; \
                  $(MAKE) \
                          -f $(firstword $(MAKEFILE_LIST)) \
                          --no-print-directory \
                          build WATCH_MODE=1 \
                  | grep -v "Nothing to be done for" ; \
          done
</pre>
</div>

<p>
That's it. I hope you learned a few <code>Make</code> or <code>emacs</code> tricks.
</p>
</div>
</div>
</div>
