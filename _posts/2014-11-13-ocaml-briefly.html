---
layout: post
title: "OCaml Briefly"
date:   2014-11-13 14:00:00
categories: ocaml
---

<p>
this document gives you a brief tour of <a href="https://ocaml.org/">OCaml</a>. It covers a rather
small selection of features; the selection has been based on what
features I personally think represent OCaml the best.
</p>

<p>
This document does very little to explain use-cases for the selected
features but rather focuses on syntax. For a more in-depth coverage of
all of these features I recommend reading the <a href="http://caml.inria.fr/pub/docs/manual-ocaml/">OCaml Document and User's
Manual</a> and <a href="https://realworldocaml.org/">Real World OCaml</a>.
</p>

<p>
For each feature there is a small explaination of the syntax, some
examples, and links for further reading. As such this document is
ideal for someone who wants to get a taste of the features of OCaml or
who want to learn more about a specific feature.
</p>

<p>
If you have any comments please reach out to me at <a href="mailto:mads379@gmail.com">mads379@gmail.com</a>
or <a href="http://www.twitter.com/mads_hartmann">@mads_hartmann</a> on twitter.
</p>

<p>
<b>Note</b>: This is still a work in progress. I haven't yet covered the
following: pattern matching, variants, records, modules, functors,
exceptions, Abstract Data Types, Generalized Algebraic Datatypes, and
much more.
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Lists, Arrays, and Tuples</a></li>
<li><a href="#sec-2">2. Let-bindings</a></li>
<li><a href="#sec-3">3. Functions</a>
<ul>
<li><a href="#sec-3-1">3.1. Defining functions</a>
<ul>
<li><a href="#sec-3-1-1">3.1.1. Labeled arguments</a></li>
<li><a href="#sec-3-1-2">3.1.2. Optional arguments</a></li>
<li><a href="#sec-3-1-3">3.1.3. Default argument</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Lists, Arrays, and Tuples</h2>
<div class="outline-text-2" id="text-1">
<p>
A <code>List</code> is constructed using square brackets where the elements are
separated by semi-colons:
</p>
<div class="org-src-container">

<pre class="src src-ocaml">[ 1 ; 2; 3 ];;
</pre>
</div>

<pre class="example">
- : int list = [1; 2; 3]
</pre>

<p>
An <code>Array</code> is constructed using square brackets with bars where the
elements are separated by semi-colons:
</p>
<div class="org-src-container">

<pre class="src src-ocaml">[| 1 ; 2; 3 |];;
</pre>
</div>

<pre class="example">
- : int array = [|1; 2; 3|]
</pre>

<p>
<code>Tuples</code> are constructed using parens and the elements are separated
using commas:
</p>
<div class="org-src-container">

<pre class="src src-ocaml">( "foo", "bar", "foobar" )
</pre>
</div>
<pre class="example">
- : string * string * string = ("foo", "bar", "foobar")
</pre>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Let-bindings</h2>
<div class="outline-text-2" id="text-2">
<p>
A let-binding associates an identifier with a value. It is introduced
using the following syntax <code>let &lt;identifier&gt; = &lt;expression&gt; in
&lt;expression&gt;</code>.
</p>
<div class="org-src-container">

<pre class="src src-ocaml">let hi = "hi " in
let there = "there!" in
hi ^ there;;
</pre>
</div>
<pre class="example">
hi there!
</pre>

<p>
The <code>^</code> is a function that concatenates two strings. The <code>^</code> function
is used as an infix operator in the example above but it could just as
easily have been invoked in a prefix manner as shown below.
</p>
<div class="org-src-container">

<pre class="src src-ocaml">(^) "Hi " "there";;
</pre>
</div>
<pre class="example">
Hi there
</pre>

<p>
Let-bindings are also used to declare functions. More on that in the
next section.
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Functions</h2>
<div class="outline-text-2" id="text-3">
<p>
As was shown in the previous section you invoke a function by adding
the arguments after the function name separated by whitespace.
</p>
<div class="org-src-container">

<pre class="src src-ocaml">min 42 10;;
</pre>
</div>
<pre class="example">
10
</pre>

<p>
It might take some time to get used to separating function arguments
with whitespace rather than commas as you do in other programming
languages. In another language the above example might look like this:
</p>
<div class="org-src-container">

<pre class="src src-ocaml">min(10,24);;
</pre>
</div>
<pre class="example">
- : int * int -&gt; int * int = &lt;fun&gt;
</pre>

<p>
However, in OCaml this will <a href="http://en.wikipedia.org/wiki/Partial_application">partially apply</a> the function <code>min</code> with
one arguemnt, the tuple <code>(10, 24)</code>. Partial application is another
nice feature of OCaml that allows you to supply <code>N</code> arguments to a
function of arity <code>X</code> and get a function of arity <code>X-N</code> in
return. This is possible as all functions in OCaml are <a href="http://en.wikipedia.org/wiki/Currying">curried</a>.
</p>
<div class="org-src-container">

<pre class="src src-ocaml">let at_least_42 = max 42 in
at_least_42 22;;
</pre>
</div>
<pre class="example">
42
</pre>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Defining functions</h3>
<div class="outline-text-3" id="text-3-1">
<p>
 A function is defined using the following syntax <code>let &lt;name&gt; &lt;arg1&gt;
&lt;arg2&gt; = &lt;expression&gt; in &lt;expression&gt;</code>, that is, the function name
followed by it's arguments separated by whitespace.
</p>

<p>
The following is a function that takes one argument <code>x</code> (which is
inferred to be an integer) and returns the square value of that
integer.
</p>
<div class="org-src-container">

<pre class="src src-ocaml">let square x = x * x;;
</pre>
</div>
<pre class="example">
val square : int -&gt; int = &lt;fun&gt;
</pre>

<p>
You can use the <code>fun</code> keyword to introduce a lambda, it has the
following syntax <code>fun &lt;arg1&gt; &lt;arg2&gt; -&gt; &lt;expression&gt;</code>. So the example
above is equivalent to this:
</p>
<div class="org-src-container">

<pre class="src src-ocaml">let square = fun x -&gt; x * x;;
</pre>
</div>
<pre class="example">
val square : int -&gt; int = &lt;fun&gt;
</pre>

<p>
As mentioned earlier some functions can be used as infix operators. A
function can be used as in infix operator if one of the following
names are used <code>! $ % &amp; * + - . / : &lt; = &gt; ? @ ^ | ~</code>. Read more about
infix and prefix functions in <a href="https://realworldocaml.org/v1/en/html/variables-and-functions.html#prefix-and-infix-operators">this section</a> of Real World OCaml.
</p>

<p>
If your function only takes one argument and you want to pattern match
on it you can use the <code>function</code> keyword (please ignore this horribly
inefficient implementation I'm about to show you):
</p>
<div class="org-src-container">

<pre class="src src-ocaml">let rec sum = function
  | x :: xs -&gt; x + (sum xs)
  | [] -&gt; 0
in sum [1;2;3;4;5;1;2];;
</pre>
</div>
<pre class="example">
18
</pre>

<p>
More on pattern matching <a href="http://mads379.github.io/ocaml/2014/11/13/ocaml-briefly.html#sec-3-1">later</a>. The previous example also shows that
if you want to define a <a href="http://en.wikipedia.org/wiki/Recursion_(computer_science)">recursive function</a> in OCaml you have to use
the <code>rec</code> keyword.
</p>
</div>

<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> Labeled arguments</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
By prefixing an arugment with <code>~</code> you can give it a label which
makes the code easier to read and makes the order of the arguments
irrilevant.
</p>
<div class="org-src-container">

<pre class="src src-ocaml">let welcome ~greeting ~name = Printf.printf "%s %s\n" greeting name in
welcome ~name:"reader" ~greeting:"Hi"
</pre>
</div>
<pre class="example">
Hi reader
- : unit = ()
</pre>
</div>
</div>

<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> Optional arguments</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
By prefixing an arugment with <code>?</code> you can make it optional. The value
of optional arguments are represented using the <a href="https://realworldocaml.org/v1/en/html/a-guided-tour.html#options"><code>Option</code> type</a>.
</p>
<div class="org-src-container">

<pre class="src src-ocaml">let welcome ?greeting_opt name =
  let greeting = match greeting_opt with
    | Some greeting -&gt; greeting
    | None -&gt; "Hi"
  in
  Printf.printf "%s %s\n" greeting name
in
welcome ~greeting_opt:"Hey" "reader" ;
welcome ?greeting_opt:None "reader"
</pre>
</div>
<pre class="example">
Hey reader
Hi reader
- : unit = ()
</pre>
</div>
</div>

<div id="outline-container-sec-3-1-3" class="outline-4">
<h4 id="sec-3-1-3"><span class="section-number-4">3.1.3</span> Default argument</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
For optional arguments you can provide a default value. Thus the
previous example could also have been written as such:
</p>
<div class="org-src-container">

<pre class="src src-ocaml">let welcome ?(greeting="Hi") name =
  Printf.printf "%s %s\n" greeting name
in
welcome ~greeting:"Hey" "reader" ;
welcome "reader"
</pre>
</div>
<pre class="example">
Hey reader
Hi reader
- : unit = ()
</pre>
</div>
</div>
</div>
</div>
