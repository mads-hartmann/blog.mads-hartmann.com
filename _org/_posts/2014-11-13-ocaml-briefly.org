#+STARTUP: showall no-indent
#+OPTIONS: toc:nil
#+OPTIONS: ^:nil
#+BEGIN_HTML
---
layout: post
title: "OCaml Briefly"
date:   2014-11-13 14:00:00
categories: ocaml
---
#+END_HTML

# (setq tuareg-interactive-buffer-name "*ocaml-toplevel*")

this document gives you a brief tour of [[https://ocaml.org/][OCaml]]. It covers a rather
small selection of features; the selection has been based on what
features I personally think represent OCaml the best.

This document does very little to explain use-cases for the selected
features but rather focuses on syntax. For a more in-depth coverage of
all of these features I recommend reading the [[http://caml.inria.fr/pub/docs/manual-ocaml/][OCaml Document and User's
Manual]] and [[https://realworldocaml.org/][Real World OCaml]].

For each feature there is a small explaination of the syntax, some
examples, and links for further reading. As such this document is
ideal for someone who wants to get a taste of the features of OCaml or
who want to learn more about a specific feature.

If you have any comments please reach out to me at [[mailto:mads379@gmail.com][mads379@gmail.com]]
or [[http://www.twitter.com/mads_hartmann][@mads_hartmann]] on twitter.

*Note*: This is still a work in progress. I haven't yet covered the
following: pattern matching, variants, records, modules, functors,
exceptions, Abstract Data Types, Generalized Algebraic Datatypes, and
much more.

#+TOC: headlines 3

* Lists, Arrays, and Tuples
A ~List~ is constructed using square brackets where the elements are
separated by semi-colons:
#+BEGIN_SRC ocaml :exports both
  [ 1 ; 2; 3 ];;
#+END_SRC

An ~Array~ is constructed using square brackets with bars where the
elements are separated by semi-colons:
#+BEGIN_SRC ocaml :exports both
  [| 1 ; 2; 3 |];;
#+END_SRC

~Tuples~ are constructed using parens and the elements are separated
using commas:
#+BEGIN_SRC ocaml :exports both
  ( "foo", "bar", "foobar" )
#+END_SRC
#+RESULTS:
: - : string * string * string = ("foo", "bar", "foobar")

* Let-bindings
A let-binding associates an identifier with a value. It is introduced
using the following syntax ~let <identifier> = <expression> in
<expression>~.
#+BEGIN_SRC ocaml :exports both
  let hi = "hi " in
  let there = "there!" in
  hi ^ there;;
#+END_SRC
#+RESULTS:
: hi there!

The ~^~ is a function that concatenates two strings. The ~^~ function
is used as an infix operator in the example above but it could just as
easily have been invoked in a prefix manner as shown below.
#+BEGIN_SRC ocaml :exports both
  (^) "Hi " "there";;
#+END_SRC
#+RESULTS:
: Hi there

Let-bindings are also used to declare functions. More on that in the
next section.

* Functions
As was shown in the previous section you invoke a function by adding
the arguments after the function name separated by whitespace.
#+BEGIN_SRC ocaml :exports both
  min 42 10;;
#+END_SRC
#+RESULTS:
: 10

It might take some time to get used to separating function arguments
with whitespace rather than commas as you do in other programming
languages. In another language the above example might look like this:
#+BEGIN_SRC ocaml :exports both
  min(10,24);;
#+END_SRC
#+RESULTS:
: - : int * int -> int * int = <fun>

However, in OCaml this will [[http://en.wikipedia.org/wiki/Partial_application][partially apply]] the function ~min~ with
one arguemnt, the tuple ~(10, 24)~. Partial application is another
nice feature of OCaml that allows you to supply ~N~ arguments to a
function of arity ~X~ and get a function of arity ~X-N~ in
return. This is possible as all functions in OCaml are [[http://en.wikipedia.org/wiki/Currying][curried]].
#+BEGIN_SRC ocaml :exports both
  let at_least_42 = max 42 in
  at_least_42 22;;
#+END_SRC
#+RESULTS:
: 42

** Defining functions
 A function is defined using the following syntax ~let <name> <arg1>
<arg2> = <expression> in <expression>~, that is, the function name
followed by it's arguments separated by whitespace.

The following is a function that takes one argument ~x~ (which is
inferred to be an integer) and returns the square value of that
integer.
#+BEGIN_SRC ocaml :exports both
  let square x = x * x;;
#+END_SRC
#+RESULTS:
: val square : int -> int = <fun>

You can use the ~fun~ keyword to introduce a lambda, it has the
following syntax ~fun <arg1> <arg2> -> <expression>~. So the example
above is equivalent to this:
#+BEGIN_SRC ocaml :exports both
  let square = fun x -> x * x;;
#+END_SRC
#+RESULTS:
: val square : int -> int = <fun>

As mentioned earlier some functions can be used as infix operators. A
function can be used as in infix operator if one of the following
names are used ~! $ % & * + - . / : < = > ? @ ^ | ~~. Read more about
infix and prefix functions in [[https://realworldocaml.org/v1/en/html/variables-and-functions.html#prefix-and-infix-operators][this section]] of Real World OCaml.

If your function only takes one argument and you want to pattern match
on it you can use the ~function~ keyword (please ignore this horribly
inefficient implementation I'm about to show you):
#+BEGIN_SRC ocaml :exports both
  let rec sum = function
    | x :: xs -> x + (sum xs)
    | [] -> 0
  in sum [1;2;3;4;5;1;2];;
#+END_SRC
#+RESULTS:
: 18

More on pattern matching [[http://mads379.github.io/ocaml/2014/11/13/ocaml-briefly.html#sec-3-1][later]]. The previous example also shows that
if you want to define a [[http://en.wikipedia.org/wiki/Recursion_(computer_science)][recursive function]] in OCaml you have to use
the ~rec~ keyword.

*** Labeled arguments
By prefixing an arugment with ~~~ you can give it a label which
makes the code easier to read and makes the order of the arguments
irrilevant.
#+BEGIN_SRC ocaml :exports both :result output
  let welcome ~greeting ~name = Printf.printf "%s %s\n" greeting name in
  welcome ~name:"reader" ~greeting:"Hi"
#+END_SRC
#+RESULTS:
: Hi reader
: - : unit = ()

*** Optional arguments
By prefixing an arugment with ~?~ you can make it optional. The value
of optional arguments are represented using the [[https://realworldocaml.org/v1/en/html/a-guided-tour.html#options][~Option~ type]].
#+BEGIN_SRC ocaml :exports both :result output
  let welcome ?greeting_opt name =
    let greeting = match greeting_opt with
      | Some greeting -> greeting
      | None -> "Hi"
    in
    Printf.printf "%s %s\n" greeting name
  in
  welcome ~greeting_opt:"Hey" "reader" ;
  welcome ?greeting_opt:None "reader"
#+END_SRC
#+RESULTS:
: Hey reader
: Hi reader
: - : unit = ()

*** Default argument
For optional arguments you can provide a default value. Thus the
previous example could also have been written as such:
#+BEGIN_SRC ocaml :exports both :result output
  let welcome ?(greeting="Hi") name =
    Printf.printf "%s %s\n" greeting name
  in
  welcome ~greeting:"Hey" "reader" ;
  welcome "reader"
#+END_SRC
#+RESULTS:
: Hey reader
: Hi reader
: - : unit = ()
