---
layout: default
---
# Links - July 2016

## The Uber Engineering Tech Stack
This is a two part overview ([part 1][uber-part-1] and
[part 2][uber-part-2]) of the Uber tech stack. I love these kinds of
overviews. It's definitely worth a read/skim.

## [The functional innards of Docker for Mac and Windows](https://www.youtube.com/watch?v=zqFDEDl5Zes) by [Anil Madhavapeddy](https://twitter.com/avsm).
This is a Very cool < 30 min. talk on some of the implementation
details of Docker for Mac and Windows. I was curious what the result
would be when I heard the news that
[Unikernel Systems joined Docker](http://unikernel.org/blog/2016/uniks-joins-docker). After
watching this I'm positive that the result is awesome.

Here's my attempt to recap how it works. They're using the
[Hypervisor.Framework](https://developer.apple.com/library/mac/documentation/DriversKernelHardware/Reference/Hypervisor/index.html)
that OS X provides which allows you to interact with the
virtualization technologies in user-space.  Using this they're running
a Linux distribution (that's based on
[alpine](https://www.alpinelinux.org/)) whose sole purpose is to run
Docker containers. Now in order to give the users of Docker for OS X
the best experience they want to hide the fact that you're running
Linux in a hypervisor just to run Docker containers; it should appear
to the users as if they're simply running Docker containers by magic
(no Linux involved). The cool trick they're using to achieve this is
to use some of the many OCaml libraries for various protocols
(TCP/HTTP/TLS etc.) to parse the "traffic" generated by Linux and map
it into OS X system calls, thus making it appear to OS X that all the
traffic and file changes etc. are no different from what Safari or
Emacs would generate. Very cool.

From the talk it becomes very clear that Docker found just the right
people for the job. The timing, and the massive experience of the
Unikernel Systems team seems to be just the right fit for Docker.

## [Two years of Eve](http://www.chris-granger.com/2016/07/21/two-years-of-eve/) by [Chris Granger](https://twitter.com/ibdknox)
After two years of prototyping the Eve team have decided what they'll
go forward with. They're splitting Eve up into two parts: **Eve the
Platform** and **Eve the UI**.

The platform is a relational datastore and a temporal logic
language. One of the reasons for releasing the platform before the UI
is:

  > we need developers to like it before end users will. Technology
  > diffuses from technical people to non-technical people over time. If
  > Eve doesn't find some home with the early adopters of technology, it's
  > unlikely to find its way to anyone else.

I look forward to playing around with the platform when it's released
in the fall.

I really enjoy following the work they’re doing with Eve and I found
Chris Granger's video
"[In Search of Tomorrow](https://www.youtube.com/watch?v=VZQoAKJPbh8)"
very entertaining. The idea of creating tools for thinking resonates
very well with me.

## [The serverless economy – why you should care about serverless](http://redmonk.com/jgovernor/2016/07/01/the-serverless-economy-why-you-should-care-about-serverless/) by [James Governor](https://twitter.com/monkchips?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor)
A nice short article about serverless computing and what
[James Governor](https://twitter.com/monkchips?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor)
finds interesting about them. Some of the interesting points being
that you only have to pay for what your customers use (auto-scaling
taken to the extreme) and that it might enable you to do more with
less engineering power.

## [Quantum Computing: A Primer](http://a16z.com/2016/06/26/quantum-computing-explained/) by [Frank Chen](http://a16z.com/author/frank-chen/).
Another interesting video by Andreessen Horowitz (last month I saw
their [AI primer](https://vimeo.com/170189199)).  It gives a little bit of history, theory behind how
a quantum computer works, why it's hard to build and finally what we
could use them for if we had them.

## [The AI Revolution: Our Immortality or Extinction](http://waitbutwhy.com/2015/01/artificial-intelligence-revolution-1.html) by [Tim Urban](https://twitter.com/waitbutwhy) of [Wait buy Why](http://waitbutwhy.com/)
This is a great, very approachable explanation of AI and why you
should care. The intro sums it up pretty well

  > It hit me pretty quickly that what’s happening in the world of AI
  > is not just an important topic, but by far THE most important
  > topic for our future.

It's a bit of a long read but it's definitely worth it
([part 1](http://waitbutwhy.com/2015/01/artificial-intelligence-revolution-1.html),
[part 2](http://waitbutwhy.com/2015/01/artificial-intelligence-revolution-2.html)). If
you're into this kind of stuff I can also recommend
[Nick Bostroms](http://www.nickbostrom.com/) book
[Super Intelligence](https://www.amazon.com/Superintelligence-Dangers-Strategies-Nick-Bostrom/dp/0199678111?ie=UTF8&redirect=true).

## [The Roots of Lisp](http://www.paulgraham.com/rootsoflisp.html) by [Paul Graham](http://www.paulgraham.com/).
This is an old-ish essay by Paul Graham where he explains the core of
Lisp. Even though the essay is from 2001 it's still worth a read. I
got it recommended by a colleague from issuu that had read it before
starting to endeavour in a larger elisp project. My reasons for reading
the article was similar. I've been happily hacking around in Emacs
Lisp for quite some time, and due to how easy it is to hack around
I've been able to achieve my tasks, but I never sat down and learned
the language as you would with other languages.

There are two really interesting quotes

  > What we have here is a remarkably elegant model of computation.
  > Using just quote atom eq car cdr cons and cond we can define a
  > function eval that actually implements our language and then using
  > that we can define any additional function we want

and

  > If you understand McCarthy's eval you understand more than just a
  > stage in the history of languages. These ideas are still the
  > semantic core of Lisp today. So studying McCarthy's original paper
  > shows us in a sense what Lisp really is. It's not something that
  > McCarthy designed so much as something he discovered. It s not
  > intrinsically a language for AI or for rapid prototyping or any
  > other task at that level. It's what you get or one thing you get
  > when you try to axiomatize computation

## [Mastering Programming](https://www.facebook.com/notes/kent-beck/mastering-programming/1184427814923414) by [Kent Beck](https://twitter.com/KentBeck)
A very short list of tips on how to go from a journeyman to a master
programmer. My favorite is the last one:

  > 80/15/5. Spend 80% of your time on low-risk/reasonable-payoff
  > work. Spend 15% of your time on related high-risk/high-payoff
  > work. Spend 5% of your time on things that tickle you, regardless
  > of payoff. Teach the next generation to do your 80% job. By the
  > time someone is ready to take over, one of your 15% experiments
  > (or, less frequently, one of your 5% experiments) will have paid
  > off and will become your new 80%. Repeat.

Aparrently it's a rule he learned from Sheryl Sandberg. He wrote a bit longer
article on it [here](https://www.facebook.com/notes/kent-beck/fresh-work-80155/1186004658099063).

## [Mutexes and JavaScript](https://blog.jcoglan.com/2016/07/12/mutexes-and-javascript/) by James Coglan
Cute little mutex implementation and why you need them in Javascript
even though you don't have multiple threads: TL;DR you have async.

## [How to Use Elm at Work](http://elm-lang.org/blog/how-to-use-elm-at-work) by [Evan Czaplicki](https://twitter.com/czaplic)
How to successfully introduce Elm at your workplace. It's based on a
bunch of success stories. Seems like solid advice.

## [Great Software Isn’t Built To Last, It’s Built To Die Gracefully](https://medium.com/building-freshbooks/great-software-isn-t-built-to-last-it-s-built-to-die-gracefully-594df9c3a470#.lmwoaivja) by Zach Mathew
The main point is "Don’t build for the future, build for future
change". He lists four tips:

- Monitoring over scalability
- Test behavior, not implementation
- Keep error logs squeaky clean
- Write less code

## [The future of Scala with creator Martin Odersky at the 2016 Scala Days in Berlin](https://www.youtube.com/watch?v=xs9GNWa8iK4&utm_content=bufferefcfc&utm_medium=social&utm_source=twitter.com&utm_campaign=buffer)
A short interview with Martin Odersky. The point I find most
interesting is that they're considering splitting the standard
library into smaller components to keep it small in the hope that the
community would create another distribution that is "batteries"
included that is more comprehensive

## [Pragmatic Modularity][prgmatic-modularity] by [Mathias Buus][mathias-buus]
Good advice to keep in mind when publishing node modules (or any
package, really).

## [Example Driven Development][example-driven-development] by [Wilfred Hughes][_wilfredh]
Very cool idea. Given some example input and the expected output this
Emacs package will find a function that does what you want (if such a
function exists). I think this is a pretty cool idea and the
implementation is pretty neat as well as I uses a couple of Emacs UI
features to provide a nice experience.

[uber-part-1]: https://eng.uber.com/tech-stack-part-one/
[uber-part-2]: https://eng.uber.com/tech-stack-part-two/
[prgmatic-modularity]: http://mafintosh.com/pragmatic-modularity.html
[mathias-buus]: https://twitter.com/mafintosh
[example-driven-development]: http://www.wilfred.me.uk/blog/2016/07/30/example-driven-development/
[_wilfredh]: https://twitter.com/_wilfredh
